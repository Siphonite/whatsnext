use std::str::FromStr;
use std::sync::Arc;

use anyhow::{anyhow, Result};
use anchor_client::{Client, Cluster, Program};
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{read_keypair_file, Keypair, Signer},
    pubkey::Pubkey,
};

use crate::config::AppConfig;

// Correct module paths generated by Anchor
use candle_markets::accounts as accounts_mod;
use candle_markets::instruction as instruction_mod;

pub struct SolanaClient {
    pub program_id: Pubkey,
    pub payer: Arc<Keypair>,
    pub cluster: Cluster,
}

impl SolanaClient {
    pub fn new(cfg: &AppConfig) -> Result<Self> {
        let payer = Arc::new(
            read_keypair_file(&cfg.admin_keypair)
                .map_err(|e| anyhow!("failed to read keypair {}: {}", cfg.admin_keypair, e))?,
        );

        let cluster = Cluster::Custom(cfg.rpc_url.clone(), cfg.rpc_url.clone());

        let program_id = Pubkey::from_str(&cfg.program_id)
            .map_err(|e| anyhow!("PROGRAM_ID in .env is invalid: {}", e))?;

        Ok(Self { program_id, payer, cluster })
    }

    pub fn program(&self) -> Program<Arc<Keypair>> {
        let client = Client::new_with_options(
            self.cluster.clone(),
            self.payer.clone(),
            CommitmentConfig::confirmed(),
        );
        client.program(self.program_id).unwrap()
    }

    pub fn derive_market_pda(&self, market_id: u64) -> (Pubkey, u8) {
        let seed = market_id.to_le_bytes();
        Pubkey::find_program_address(&[b"market", &seed], &self.program_id)
    }

    #[allow(dead_code)]
    pub fn derive_bet_pda(&self, user: &Pubkey, market: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[b"bet", user.as_ref(), market.as_ref()],
            &self.program_id,
        )
    }

    // Helper to get system program ID
    fn system_program_id() -> Pubkey {
        Pubkey::from_str("11111111111111111111111111111111").unwrap()
    }

    pub fn create_market_and_send(
        &self,
        asset: String,
        open_price: u64,
        start_time: i64,
        end_time: i64,
        market_id: u64,
    ) -> Result<String> {
        let program = self.program();

        let (market_pda, _) = self.derive_market_pda(market_id);

        let accounts = accounts_mod::CreateMarket {
            market: market_pda,
            authority: self.payer.pubkey(),
            system_program: Self::system_program_id(),
        };

        let args = instruction_mod::CreateMarket {
            asset,
            open_price,
            start_time,
            end_time,
            market_id,
        };

        let sig = program
            .request()
            .accounts(accounts)
            .args(args)
            .signer(&*self.payer)
            .send()
            .map_err(|e| anyhow!("Failed to send create_market tx: {}", e))?;

        Ok(sig.to_string())
    }

    #[allow(dead_code)]
    pub fn settle_market_and_send(
        &self,
        market_id: u64,
        close_price: u64,
    ) -> Result<String> {
        let program = self.program();

        let (market_pda, _) = self.derive_market_pda(market_id);

        let accounts = accounts_mod::SettleMarket {
            market: market_pda,
            authority: self.payer.pubkey(),
        };

        let args = instruction_mod::SettleMarket {
            close_price,
        };

        let sig = program
            .request()
            .accounts(accounts)
            .args(args)
            .signer(&*self.payer)
            .send()
            .map_err(|e| anyhow!("Failed to send settle_market tx: {}", e))?;

        Ok(sig.to_string())
    }
}