use std::{rc::Rc, str::FromStr};

use anyhow::{Context, Result};
use anchor_client::{Client, Cluster, Program};
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{read_keypair_file, Keypair, Signer},
    pubkey::Pubkey,
    system_program,
};
use crate::config::AppConfig;

// Typed imports from on-chain crate (anchor)
// These paths match the pattern produced by `#[program] pub mod candle_markets { ... }`
use candle_markets::candle_markets::accounts as accounts_mod;
use candle_markets::candle_markets::instruction as instruction_mod;

/// Thin wrapper for Anchor client + payer
pub struct SolanaClient {
    pub client: Client,
    pub payer: Rc<Keypair>,
    pub program_id: Pubkey,
}

impl SolanaClient {
    /// Create a new SolanaClient using values from AppConfig
    pub fn new(cfg: &AppConfig) -> Result<Self> {
        // load payer keypair
        let keypair_path = &cfg.admin_keypair;
        let keypair = read_keypair_file(keypair_path)
            .with_context(|| format!("failed to read keypair file from {}", keypair_path))?;
        let payer = Rc::new(keypair);

        // Cluster::Custom accepts (rpc, ws) so we pass same rpc for both
        let cluster = Cluster::Custom(cfg.rpc_url.clone(), cfg.rpc_url.clone());
        let commitment = CommitmentConfig::confirmed();

        let client = Client::new_with_options(cluster, payer.clone(), commitment);

        let program_id = Pubkey::from_str(&cfg.program_id)
            .context("PROGRAM_ID in .env is invalid")?;

        Ok(Self { client, payer, program_id })
    }

    /// Program handle bound to configured program id
    pub fn program(&self) -> Program {
        self.client.program(self.program_id)
    }

    // ----------------------------
    // PDA helpers
    // ----------------------------

    /// Derive market PDA and bump using same seeds as on-chain:
    /// seeds = [b"market", market_id.to_le_bytes()]
    pub fn derive_market_pda(&self, market_id: u64) -> (Pubkey, u8) {
        let seed = market_id.to_le_bytes();
        Pubkey::find_program_address(&[b"market".as_ref(), &seed], &self.program_id)
    }

    /// Derive bet PDA and bump using seeds:
    /// seeds = [b"bet", user_pubkey, market_pubkey]
    pub fn derive_bet_pda(&self, user: &Pubkey, market: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"bet".as_ref(), user.as_ref(), market.as_ref()], &self.program_id)
    }

    // ----------------------------
    // Typed RPC calls (create / settle)
    // ----------------------------

    /// Call the on-chain `create_market` instruction (typed).
    ///
    /// Params:
    /// - asset: string, e.g. "SOL/USDT"
    /// - open_price: u64 price unit consistent with program (decide convention)
    /// - start_time/end_time: unix timestamps (i64)
    /// - market_id: u64 unique id you choose (backend must track)
    ///
    /// Returns: signature string on success
    pub fn create_market_and_send(
        &self,
        asset: String,
        open_price: u64,
        start_time: i64,
        end_time: i64,
        market_id: u64,
    ) -> Result<String> {
        let program = self.program();

        // derive PDA for market
        let (market_pda, _bump) = self.derive_market_pda(market_id);

        // Build the accounts struct generated by Anchor
        let accounts = accounts_mod::CreateMarket {
            market: market_pda,
            authority: self.payer.pubkey(),
            system_program: system_program::id(),
        };

        // Build the args struct generated by Anchor
        let args = instruction_mod::CreateMarket {
            asset,
            open_price,
            start_time,
            end_time,
            market_id,
        };

        // Build and send tx
        let sig = program
            .request()
            .accounts(accounts)
            .args(args)
            .signer(&*self.payer) // ensure the payer signs
            .send()?;

        Ok(sig.to_string())
    }

    /// Call the on-chain `settle_market` instruction (typed).
    ///
    /// Params:
    /// - market_id: u64 to derive the market PDA
    /// - close_price: u64 final close price
    pub fn settle_market_and_send(&self, market_id: u64, close_price: u64) -> Result<String> {
        let program = self.program();

        // derive market PDA
        let (market_pda, _bump) = self.derive_market_pda(market_id);

        // Build accounts struct
        let accounts = accounts_mod::SettleMarket {
            market: market_pda,
            authority: self.payer.pubkey(),
        };

        // Build args struct
        let args = instruction_mod::SettleMarket {
            close_price,
        };

        let sig = program
            .request()
            .accounts(accounts)
            .args(args)
            .signer(&*self.payer)
            .send()?;

        Ok(sig.to_string())
    }
}
